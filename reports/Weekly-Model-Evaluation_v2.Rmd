---
title: "Weekly Model Evaluations for State-Level COVID-19 Forecasts"
subtitle: "COVID-19 Forecast Hub and Delphi Group Forecast Evaluation Working Group"
author: "(alphabetical order) Jacob Bien, Johannes Bracher, Logan C Brooks, Estee Y Cramer, Jed Grabman, Kate Harwood, Evan Ray, Nicholas G Reich, Chris Scott" 
date: "`r format(Sys.time(), '%B %d, %Y')`"
output:
  html_document:
    toc: true
    toc_float:
      collapsed: false
      smooth_scroll: false
      
---
<!-- code to run rmarkdown::render(input="./vignettes/covidHubUtils-overview.Rmd") -->

<!-- Code for adding logo at the top -->

<!-- <script> -->
<!--   $(document).ready(function() { -->
<!--     $('#TOC').parent().prepend('<div id=\"nav_logo\"><a href=\"https://covid19forecasthub.org/\" target=\"_blank\"><img src=\"https://github.com/reichlab/covid19-forecast-hub-web/raw/master/images/forecast-hub-logo_DARKBLUE.png\"></a></div>'); -->
<!--   }); -->
<!-- </script> -->

<style>
#nav_logo {
  width: 100%;
  margin-top: 20px;
}

#TOC {
  background: url("https://github.com/reichlab/covid19-forecast-hub-web/raw/master/images/forecast-hub-logo_DARKBLUE-20px-padding.png");
  background-size: contain;
  padding-top: 80px !important;
  background-repeat: no-repeat;
}
</style>
<!-- </style> -->

```{r setup, include=FALSE}
#load libraries
knitr::opts_chunk$set(echo = FALSE, message = FALSE, warning = FALSE)
library(lubridate)
#library(covidcast)
#library(evalcast)
library(RColorBrewer)
library(surveillance)
library(htmltools)
library(kableExtra)
library(covidHubUtils)
#library(zoltr)
library(plotly)
library(tidyverse)
theme_set(theme_bw())

data("hub_locations")
```

```{r prelim set values}
the_locations <- hub_locations %>% filter(geo_type == "state") %>% pull(fips) #states, us and territories

US_fips <- hub_locations %>%  filter(geo_type == "state") %>% filter(abbreviation %in% datasets::state.abb) %>% pull(fips) #only 50 states 

n_weeks_eval <- 10 #weeks included in evaluation
n_weeks_submitted <- 5 #number of weeks needed for inclusion if no longer submitting
```

```{r get-date-boundaries}
#Important dates used (likely there is a cleaner way to code this)
last_eval_sat <- as.Date(calc_target_week_end_date(today(), horizon = -1))
first_eval_sat <- last_eval_sat  - 7*(n_weeks_eval - 1)  #First Evaluated Date

last_submission_date <- last_eval_sat  - 5 #Last submission date
first_submission_date <- first_eval_sat - 11  #First submission date

first_mon_cutoff <- first_eval_sat - 5

last_1wk_target_end_date <- as.Date(calc_target_week_end_date(last_submission_date, horizon = 1)) #last 1 week ahead horizon
first_1wk_target_end_date  <- as.Date(calc_target_week_end_date(first_submission_date, horizon = 0)) #first 1 week ahead horizon

first_4wk_target_end_date  <- as.Date(calc_target_week_end_date(first_submission_date, horizon = 4)) #first horizon with all 4 target weeks evaluated 
last_4wk_target_end_date <- as.Date(calc_target_week_end_date(last_submission_date, horizon = 4))

eval_sat <- c(first_eval_sat, last_eval_sat) #range of dates evaluated 

n_weeks_missing <- 5
```

<!-- ```{r}  -->
<!-- #only use after writing truth data for the day  -->
<!-- truth_dat_case <- read.csv("truth_dat_case.csv") %>% mutate(target_end_date = as.Date(target_end_date)) -->
<!-- truth_dat_inc <- read.csv("truth_dat_inc.csv") %>% mutate(target_end_date = as.Date(target_end_date)) -->
<!-- ``` -->


```{r}
# score_case_edit_all <- read.csv("score_case_edit.csv") %>%
#   mutate(target_end_date = as.Date(target_end_date),
#          forecast_date = as.Date(forecast_date),
#          submission_sat = as.Date(submission_sat),
#          horizon = as.factor(horizon)) %>%
#   filter(!model %in% c("CU-scenario_high","CU-scenario_mid","CU-scenario_low","CU-nochange"))
# 
# score_inc_edit_all <- read.csv("score_inc_edit.csv") %>%
#   mutate(target_end_date = as.Date(target_end_date),
#          forecast_date = as.Date(forecast_date),
#          submission_sat = as.Date(submission_sat),
#          horizon = as.factor(horizon)) %>%
#   filter(!model %in% c("CU-scenario_high","CU-scenario_mid","CU-scenario_low","CU-nochange"))
```

```{r}
load(file = "truth_dat_case.rda")
load(file = "truth_dat_inc.rda")

load(file = "score_case_all.rda") 
load(file = "score_inc_all.rda") 
```

```{r inclusion in leaderboard recent}
#Filtered to include only models in scoreboard (number of obs and calibration)
score_case_leaderboard <- score_case_all %>%
  filter(n_weeks >= n_weeks_submitted |  n_weeks_3wksPrior >= 2) #filter if missing more than half of forecasts or if missing more than 2 forecasts in the last 3 weeks 

#Filtered to include only models in scoreboard
score_inc_leaderboard <- score_inc_all %>%
  filter(n_weeks >= n_weeks_submitted |  n_weeks_3wksPrior >= 2) #filter if missing more than half of forecasts or if missing more than 2 forecasts in the last 3 weeks 
```

```{r only 10 weeks back}
score_case_10wks <- score_case_all %>%
  filter(target_end_date >= first_eval_sat)

score_inc_10wks <- score_inc_all %>%
  filter(target_end_date >= first_eval_sat)
```

```{r inclusion in leaderboard historical}
score_case_historical <- score_case_all %>%
  filter(n_weeks > (max(n_weeks)*0.5)) %>% droplevels()

score_inc_historical <- score_inc_all %>%
  filter(n_weeks > (max(n_weeks)*0.5)) %>% droplevels()
```

```{r inclusion in relative recent calculations}
#Filtered to include only models that have submitted a forecast in recent weeks and the recent forecasts
score_case_recent <- score_case_10wks  %>% 
  filter(n_weeks_10wksPrior >= max(n_weeks_10wksPrior)*0.5) %>%
  droplevels() 

score_inc_recent <- score_inc_10wks %>% 
  filter(n_weeks_10wksPrior >= max(n_weeks_10wksPrior)*0.5) %>%
  droplevels() 
```


```{r truth data plot}
#function to Plot truth data 
plot_truth <- function(dat) {
ggplot(data = dat, aes(x = target_end_date, y = value)) +
  #geom_line(color = "black") +
  geom_point() +
  geom_line(color = "black") +
  scale_x_date(name = NULL, date_breaks="1 month", date_labels = "%b %d") +
  ylab("incident cases") +
  labs(title = paste("Weekly reported COVID-19 data: \n Models evaluated from", first_eval_sat, "to", last_eval_sat, sep = " "),
                          caption="source: JHU CSSE (observed data)")+
  theme(legend.position = c(.05,.95), legend.justification = c(0,1)) +
  geom_vline(xintercept= eval_sat, linetype=2, color = "blue")
}
```

```{r location heatmap plot}
#function to plot number of locations

plot_location <- function(x){
  ggplot(x, aes(y=model, x= submission_sat, fill=n_location)) + 
    geom_tile() +
    geom_text(aes(label=n_location), size = 7) +
  scale_fill_steps(low="white", high="blue", name = "Number of Locations") +
   xlab("Submission Saturday") + ylab(NULL) +
  scale_x_date(date_labels = "%Y-%m-%d", breaks = c(x$submission_sat)) +
   theme(axis.text.x = element_text(angle = 45, hjust = 1, size = 20),
         axis.title.x = element_text(size = 30),
         axis.text.y = element_text(size = 25),
         title = element_text(size = 20)) +
    guides(fill=FALSE) 
}
```

```{r calibration table function}
calib_table <- function(x){
  x %>% 
      filter(score_name %in% c("coverage_50","coverage_95")) %>%
  pivot_wider(names_from = score_name, values_from = score_value) %>%
  group_by(model) %>%
  summarise(n_forecasts_historical = n(),
            n_forecasts_recent = sum(target_end_date >= first_eval_sat),
            mean_PI50 = round(sum(coverage_50, na.rm = TRUE) / n(),2),
            mean_PI95 = round(sum(coverage_95, na.rm = TRUE) / n(),2)) %>%
  ungroup() %>%
  arrange(-mean_PI50)
}
```


# Overview
This report provides an evaluation of the accuracy and precision of probabilistic forecasts submitted to the [COVID-19 Forecast Hub](https://covid19forecasthub.org/) over the last `r n_weeks_eval` weeks. The forecasts evaluated were submitted during the time period from `r format(first_submission_date, "%B %d, %Y")` through `r format(last_submission_date, "%B %d, %Y")`. The revision dates of this data was calculated as of `r today()`. 

In this weekly report we are evaluating forecasts made in 57 different locations (US on a national level, 50 states, and 6 territories), for 4 horizons over `r n_weeks_eval` submission weeks. We are evaluating incident cases, and incident deaths. 

Additionally, we have included a historical score report to aggregate scores from forecasts that have been submitted to the forecast hub since the first week in April.

In collaboration with the US CDC, our team collects COVID-19 forecasts from dozens of teams around the globe. Each Monday evening or Tuesday morning, we combine the most recent forecasts from each team into a single "ensemble" forecast for each of the target submissions.

Typically on Wednesday or Thursday of each week, a summary of the week's forecast from the COVID-19 Forecast Hub, including the ensemble forecast, appear on the [official CDC COVID-19 forecasting page](https://www.cdc.gov/coronavirus/2019-ncov/covid-data/forecasting-us.html).

This report has been created as a collaborative effort between the COVID-19 Forecast hub and the CMU Delphi group. 


# Incident Cases {.tabset .tabset-fade}


## Truth data and Model Submissions  {.tabset .tabset-fade}

### Truth data

This figure shows the number of incident cases reported each week.  The period between the vertical lines shows the number of weeks for which models were evaluated. 

```{r, fig.width=8, fig.height=7}
truth_US_case <- truth_dat_case %>%
  filter(location == "US")

plot_truth(dat = truth_US_case)
```


### Number of Locations

```{r filters for analysis inc case, fig.width=8, fig.height=10}
#counts of case submissions for the week

#Count of models that have submitted for last 10 evaluated weeks
n_unique_models_case <- score_case_10wks  %>%
  pull(model) %>% unique()

n_models_all_weeks <- score_case_10wks  %>% 
  filter(n_weeks_10wksPrior == max(n_weeks_10wksPrior)) %>%
  pull(model) %>% unique() %>% length()

n_models_all_locations <- score_case_10wks  %>% 
  filter(n_locations >= 50) %>%
  pull(model) %>% unique() %>% length()

n_models_all_weeks <- score_case_10wks  %>% 
  group_by(horizon) %>%
  filter(n_horizons == max(n_horizons)) %>%
  pull(model) %>% unique() %>% length()
```


This figure shows the number of locations each model submitted a weekly incidence case forecast for for the last 10 evaluated weeks. The maximum number of locations is 57, which includes all 50 states, a National level forecast, and 6 US territories. 

The dates listed on the x-axis are the Saturday before the first horizon. This is the Saturday associated with the target submission week. If a model is submitted on Tuesday - Friday, the Saturday listed occurs after the submission. If the model is submitted on a Sunday or Monday, the Saturday occurs before the submission date. 

The number of models who submitted forecasts for incident cases is `r n_unique_models_case`. The number of models that submitted forecasts for all `r n_weeks_eval` weeks was `r n_models_all_weeks`. The number of teams that submitted forecasts for all 57 locations was `r n_models_all_locations`.
```{r,fig.width=20, fig.height=20}
for_loc_figure_case <- score_case_10wks  %>%
  filter(score_name == "wis") %>%
  filter(horizon == "1") %>%
  group_by(model, submission_sat) %>%
  summarise(n_location = n()) %>%
  ungroup() %>%
  group_by(model, n_location) %>%
  mutate(n_weeks = n())

for_loc_figure_case$model <- reorder(for_loc_figure_case$model, for_loc_figure_case$n_weeks)

plot_location(for_loc_figure_case)
```

## LeaderBoard Table

Each week, we generate a leaderboard table to assess the interval coverage, relative weighted interval scores (WIS), and relative mean average errors (MAE) of each model.

A model is included in this table if it has  submitted forecasts for 5 or more weeks total, or if it has submitted forecasts during at least 2 out of the last 3 evaluated weeks. This inclusion criteria was applied in order to score models that submitted for a substantial amount of weeks at any point during the pandemic but may no longer be submitting, but also to evaluate new teams that have recently joined our forecasting efforts. 


In order to calculate each column in our table, different inclusion criteria were applied. 

* The first column in the table counts the total number of observations a team has submitted. The second column counts the number of columns a team has submitted over the last 10 weeks. For inclusion in these rows, a model had to have been submitted for at least 5 weeks overall, or at least 2 out of the last 3 weeks. 

* The next two columns highlight the calibration scores of models, at a 50% coverage and 95% coverage level respectively. Well calibrated models should have a 50% coverage level of 0.5 and a 95% coverage level of 0.95. The inclusion criteria for these columns is the same as for the first two columns. 

* The following columns (5 and 8) calculate the following: (5) adjusted relative WIS over the most recent `r n_weeks_eval` week period, (6) adjusted relative WIS over the historical period beginning the first week in April, (7) adjusted relative MAE over the most recent period, and (8) adjusted relative MAE over a historical period. For inclusion in the 10 week WIS and MAE calculations, a model must have target_end_dates in more than 50% of evaluated weeks in the recent evaluation period. For inclusion in the historical WIS and MAE calculations, a model must have forecasts with target_end_dates in more than 50% of evaluated weeks in the Historical evaluation period,

* All adjusted relative WIS and adjusted relative MAE calculations in this table are calculated using a pairwise approach to account variation in the difficulty of forecasting different weeks and locations. Models with an adjusted relative WIS or MAE lower than 1 are more accurate than the baseline and models with an adjusted relative WIS greater than 1 are less accurate than the baseline is predicting the number of incident cases. The code for this comparison can be found [here](https://github.com/jbracher/pairwise_comparisons). A preprint on this method for calculating the WIS can be found [here](https://arxiv.org/pdf/2005.12881.pdf). 


```{r}
#calibration table 
case_calibration <- calib_table(score_case_leaderboard)
```

```{r relative wis case}
#Calculate pairwise WIS
# # helper function
# next_monday <- function(date){
#   nm <- rep(NA, length(date))
#   for(i in seq_along(date)){
#     nm[i] <- date[i] + (0:6)[weekdays(date[i] + (0:6)) == "Monday"]
#   }
#   return(as.Date(nm, origin = "1970-01-01"))
# }

inc_scores <- score_case_recent %>%
  filter(!is.na(score_value)) %>%
  filter(n_locations >= 25) %>% droplevels()

# bring all timezeros to Monday:
inc_scores$timezero <- inc_scores$submission_sat

# restrict to 1-4 wk ahead state-level 
scores <- inc_scores %>% filter(horizon %in% paste(1:4),  location %in% the_locations) %>%
  select("model", "timezero", "location", "horizon", "score_name", "score_value") %>%
  filter(score_name %in% c("abs_error", "wis")) %>%
  pivot_wider(names_from = score_name, values_from = score_value) %>%
  filter(!is.na(wis)) %>%
  droplevels()


# the included models:
models <- unique(scores$model)


pairwise_comparison <- function(scores, mx, my, subset = rep(TRUE, nrow(scores)),
                                permutation_test = TRUE){
  # subsets of available scores for both models:
  subx <- subset(scores, model == mx)
  suby <- subset(scores, model == my)
  # merge together and restrict to overlap:
  sub <- merge(subx, suby, by = c("timezero", "location", "horizon"),
               all.x = FALSE, all.y = FALSE)
  ##### catch common problems:
  ##### no overlap between targets covered by x and y:
  if(nrow(sub) == 0){
    warning("No overlap of covered forecast targets for ", mx, "and", my, ". Returning NA.")
    return(list(ratio = NA, pval = NA, pval_fcd = NA, mx = mx, my = my))
  }
  ##### unavailable scores (likely because a model issues only point forecasts?)
  if(any(is.na(subx$wis))){
    warning("Some or all wis values are NA for ", mx, ". Returning NA.")
    return(list(ratio = NA, pval = NA, pval_fcd = NA, mx = mx, my = my))
  }
  if(any(is.na(suby$wis))){
    warning("Some or all wis values are NA for ", my, ". Returning NA.")
    return(list(ratio = NA, pval = NA, pval_fcd = NA, mx = mx, my = my))
  }

  # compute ratio:
  
  # matrices to store:
  results_ratio <- results_pval <- results_pval_fcd <- matrix(ncol = length(models),
                                                              nrow = length(models),
                                                              dimnames = list(models, models))

  ratio <- sum(sub$wis.x) / sum(sub$wis.y)
  # perform permutation tests:
  if(permutation_test){
    pval <- permutationTest(sub$wis.x, sub$wis.y,
                            nPermutation = 999)$pVal.permut
    ##### aggregate by forecast date:
    sub_fcd <- aggregate(cbind(wis.x, wis.y) ~ timezero, data = sub, FUN = mean)
    # catch error if too many observations
    if(nrow(sub_fcd) > 5){
      pval_fcd <- permutationTest(sub_fcd$wis.x, sub_fcd$wis.y,
                                  nPermutation = 999)$pVal.permut
    }else{
      warning("Too few observations to compute p-value for ", mx, " and ", my, " with aggregation by forecast date. Returning NA.")
      pval_fcd <- NA
    }
  }else{
    pval <- NULL
    pval_fcd <- NULL
  }
  return(list(ratio = ratio, pval = pval, pval_fcd = pval_fcd, mx = mx, my = my))
}

# matrices to store:
results_ratio <- results_pval <- results_pval_fcd <- matrix(ncol = length(models),
                                                            nrow = length(models),
                                                            dimnames = list(models, models))

set.seed(123) # set seed for permutation tests

for(mx in seq_along(models)){
  for(my in 1:mx){
    pwc <- pairwise_comparison(scores = scores, mx = models[mx], my = models[my],
                               permutation_test = FALSE)

    results_ratio[mx, my] <- pwc$ratio
    results_ratio[my, mx] <- 1/pwc$ratio
    ## commenting these out b/c no permutation test being run
    #results_pval[mx, my] <-
    #  results_pval[my, mx] <- pwc$pval
    #results_pval_fcd[mx, my] <-
    #  results_pval_fcd[my, mx] <- pwc$pval_fcd
  }
}

ind_baseline <- which(rownames(results_ratio) == "COVIDhub-baseline")
geom_mean_ratios <- exp(rowMeans(log(results_ratio[, -ind_baseline]), na.rm = TRUE))
ratios_baseline <- results_ratio[, "COVIDhub-baseline"]
ratios_baseline2 <- geom_mean_ratios/geom_mean_ratios["COVIDhub-baseline"]

tab <- data.frame(model = names(geom_mean_ratios),
                  geom_mean_ratios = geom_mean_ratios,
                  ratios_baseline = ratios_baseline,
                  ratios_baseline2 = ratios_baseline2)

tab <- tab[order(tab$ratios_baseline2), ]


pairwise_scores <- tab %>%
  mutate(relative_wis = round(ratios_baseline2, 2)) %>%
  select(model, relative_wis) 
```

```{r relative mae case }
pairabs_error_comparison <- function(scores, mx, my, subset = rep(TRUE, nrow(scores)),
                                permutation_test = TRUE){
  # subsets of available scores for both models:
  subx <- subset(scores, model == mx)
  suby <- subset(scores, model == my)
  # merge together and restrict to overlap:
  sub <- merge(subx, suby, by = c("timezero", "location", "horizon"),
               all.x = FALSE, all.y = FALSE)
  ##### catch common problems:
  ##### no overlap between targets covered by x and y:
  if(nrow(sub) == 0){
    warning("No overlap of covered forecast targets for ", mx, "and", my, ". Returning NA.")
    return(list(ratio = NA, pval = NA, pval_fcd = NA, mx = mx, my = my))
  }
  ##### unavailable scores (likely because a model issues only point forecasts?)
  if(any(is.na(subx$abs_error))){
    warning("Some or all abs_error values are NA for ", mx, ". Returning NA.")
    return(list(ratio = NA, pval = NA, pval_fcd = NA, mx = mx, my = my))
  }
  if(any(is.na(suby$abs_error))){
    warning("Some or all abs_error values are NA for ", my, ". Returning NA.")
    return(list(ratio = NA, pval = NA, pval_fcd = NA, mx = mx, my = my))
  }
  # compute ratio:
  
  # matrices to store:
  results_ratio <- results_pval <- results_pval_fcd <- matrix(ncol = length(models),
                                                            nrow = length(models),
                                                            dimnames = list(models, models))

  ratio <- sum(sub$abs_error.x) / sum(sub$abs_error.y)
  # perform permutation tests:
  if(permutation_test){
    pval <- permutationTest(sub$abs_error.x, sub$abs_error.y,
                            nPermutation = 999)$pVal.permut
    ##### aggregate by forecast date:
    sub_fcd <- aggregate(cbind(abs_error.x, abs_error.y) ~ timezero, data = sub, FUN = mean)
    # catch error if too many observations
    if(nrow(sub_fcd) > 5){
      pval_fcd <- permutationTest(sub_fcd$abs_error.x, sub_fcd$abs_error.y,
                                  nPermutation = 999)$pVal.permut
    }else{
      warning("Too few observations to compute p-value for ", mx, " and ", my, " with aggregation by forecast date. Returning NA.")
      pval_fcd <- NA
    }
  }else{
    pval <- NULL
    pval_fcd <- NULL
  }
  return(list(ratio = ratio, pval = pval, pval_fcd = pval_fcd, mx = mx, my = my))
}

# matrices to store:
results_ratio <- results_pval <- results_pval_fcd <- matrix(ncol = length(models),
                                                            nrow = length(models),
                                                            dimnames = list(models, models))
set.seed(123) # set seed for permutation tests

for(mx in seq_along(models)){
  for(my in 1:mx){
    pwc <- pairabs_error_comparison(scores = scores, mx = models[mx], my = models[my],
                               permutation_test = FALSE)

    results_ratio[mx, my] <- pwc$ratio
    results_ratio[my, mx] <- 1/pwc$ratio
    ## commenting these out b/c no permutation test being run
    #results_pval[mx, my] <-
    #  results_pval[my, mx] <- pwc$pval
    #results_pval_fcd[mx, my] <-
    #  results_pval_fcd[my, mx] <- pwc$pval_fcd
  }
}

ind_baseline <- which(rownames(results_ratio) == "COVIDhub-baseline")
geom_mean_ratios <- exp(rowMeans(log(results_ratio[, -ind_baseline]), na.rm = TRUE))
ratios_baseline <- results_ratio[, "COVIDhub-baseline"]
ratios_baseline2 <- geom_mean_ratios/geom_mean_ratios["COVIDhub-baseline"]

tab <- data.frame(model = names(geom_mean_ratios),
                  geom_mean_ratios = geom_mean_ratios,
                  ratios_baseline = ratios_baseline,
                  ratios_baseline2 = ratios_baseline2)

tab <- tab[order(tab$ratios_baseline2), ]

pairwise_scores_mae <- tab %>%
  mutate(relative_mae = round(ratios_baseline2, 2)) %>%
  select(model, relative_mae) 
```


```{r permutation test for historical data}
inc_scores <- score_case_historical %>%
  filter(n_locations >= 25) %>%
  filter(n_weeks >= 4) %>%
  droplevels()

# bring all timezeros to Monday:
inc_scores$timezero <- inc_scores$submission_sat

# restrict to 1-4 wk ahead state-level 
scores <- inc_scores %>% filter(horizon %in% paste(1:4),  location %in% the_locations) %>%
  filter(!is.na(score_value)) %>%
  select("model", "timezero", "location", "horizon", "score_name", "score_value") %>%
  filter(score_name %in% c("abs_error", "wis")) %>%
  pivot_wider(names_from = score_name, values_from = score_value)


# the included models:
models <- unique(scores$model)


# matrices to store:
results_ratio <- results_pval <- results_pval_fcd <- matrix(ncol = length(models),
                                                            nrow = length(models),
                                                            dimnames = list(models, models))

set.seed(123) # set seed for permutation tests

for(mx in seq_along(models)){
  for(my in 1:mx){
    pwc <- pairwise_comparison(scores = scores, mx = models[mx], my = models[my],
                               permutation_test = FALSE)

    results_ratio[mx, my] <- pwc$ratio
    results_ratio[my, mx] <- 1/pwc$ratio
    ## commenting these out b/c no permutation test being run
    # results_pval[mx, my] <-
    #   results_pval[my, mx] <- pwc$pval
    # results_pval_fcd[mx, my] <-
    #   results_pval_fcd[my, mx] <- pwc$pval_fcd
  }
}

ind_baseline <- which(rownames(results_ratio) == "COVIDhub-baseline")
geom_mean_ratios <- exp(rowMeans(log(results_ratio[, -ind_baseline]), na.rm = TRUE))
ratios_baseline <- results_ratio[, "COVIDhub-baseline"]
ratios_baseline2 <- geom_mean_ratios/geom_mean_ratios["COVIDhub-baseline"]

tab <- data.frame(model = names(geom_mean_ratios),
                  geom_mean_ratios = geom_mean_ratios,
                  ratios_baseline = ratios_baseline,
                  ratios_baseline2 = ratios_baseline2)

tab <- tab[order(tab$ratios_baseline2), ]

historical_wis <- tab %>%
  mutate(relative_wis_historical = round(ratios_baseline2, 2)) %>%
  select(model, relative_wis_historical) 
```

```{r}

# matrices to store:
results_ratio <- results_pval <- results_pval_fcd <- matrix(ncol = length(models),
                                                            nrow = length(models),
                                                            dimnames = list(models, models))

set.seed(123) # set seed for permutation tests

for(mx in seq_along(models)){
  for(my in 1:mx){
    pwc <- pairabs_error_comparison(scores = scores, mx = models[mx], my = models[my],
                               permutation_test = FALSE)

    results_ratio[mx, my] <- pwc$ratio
    results_ratio[my, mx] <- 1/pwc$ratio
    ## commenting these out b/c no permutation test being run
    # results_pval[mx, my] <-
    #   results_pval[my, mx] <- pwc$pval
    # results_pval_fcd[mx, my] <-
    #   results_pval_fcd[my, mx] <- pwc$pval_fcd
  }
}

ind_baseline <- which(rownames(results_ratio) == "COVIDhub-baseline")
geom_mean_ratios <- exp(rowMeans(log(results_ratio[, -ind_baseline]), na.rm = TRUE))
ratios_baseline <- results_ratio[, "COVIDhub-baseline"]
ratios_baseline2 <- geom_mean_ratios/geom_mean_ratios["COVIDhub-baseline"]

tab <- data.frame(model = names(geom_mean_ratios),
                  geom_mean_ratios = geom_mean_ratios,
                  ratios_baseline = ratios_baseline,
                  ratios_baseline2 = ratios_baseline2)

tab <- tab[order(tab$ratios_baseline2), ]


historical_mae <- tab %>%
  mutate(historical_relative_mae = round(ratios_baseline2, 2)) %>%
  select(model, historical_relative_mae) 
```


```{r}
leaderboard_table <- case_calibration %>%
  left_join(pairwise_scores) %>%
  left_join(historical_wis) %>%
  left_join(pairwise_scores_mae) %>%
  left_join(historical_mae) %>%
  arrange(relative_wis, na.last = FALSE)

DT::datatable(leaderboard_table, colnames = c("", "Model", "n historical forecasts", "n forecasts in the last 10 wks", "50% Coverage", "95% Coverage", "Relative WIS", "Historical Relative WIS", "Relative MAE", "Historical Relative MAE"), options = list(pageLength = 10, na.last = TRUE), filter = c("top"))
```



## Evaluation by Week  {.tabset .tabset-fade}

In the following figures, we have evaluated models across multiple forecasting weeks. The models included in this comparison must have submitted forecasts for all 50 states and at a national level for each time point. 

For the first 2 figures, WIS is used as a metric. The first figure shows the mean WIS across all locations for submission weeks beginning the first week in April at a 1 week horizon. The second figure shows the mean WIS aggregated across locations, however it is for a 4 week horizon.

To view specific teams, double click on the team names in the legend. To view a value on the plot, click on the point in the forecast of interest.To view a specific time of interest, hightlight that section on the graph or use the zoom functionality. 

### 1 Week Horizon WIS
```{r,fig.width=10, fig.height=6}
by_week_function <- function(df, var) {
  df %>%
  filter(score_name == var) %>%
  filter(location %in% c(US_fips, "US")) %>%
  group_by(model, target_end_date, horizon) %>%
  mutate(n_US_location = n()) %>%
  ungroup() %>%
  filter(n_US_location == max(n_US_location)) %>%
  group_by(model,horizon, target_end_date) %>%
  summarise(mean_score = mean(score_value))
}

plot_byweek_function <- function(df, var, horizon_num) {
  ggplot(data =  df %>% filter(horizon == horizon_num), aes(label = model, 
                                     labelx = target_end_date,
                                     labely = mean_score,
                                     x = target_end_date, 
                                     y = mean_score, color = model)) +
  geom_line(aes(group = model), alpha=.5) +
  geom_point(aes(group = model), alpha=.5, size = 2) +
  expand_limits(y=0) +
  scale_y_continuous(name = paste("Average",var)) +
  guides(color=FALSE, group = FALSE) +
  ggtitle(paste0("Average ", horizon_num,"-week ahead ",var," by model")) +
  xlab("Target End Date") +
  theme(axis.ticks.length.x = unit(0.5, "cm"),
    axis.text.x = element_text(vjust = 7, hjust = -0.2))
}

byweek_case <- by_week_function(score_case_all, var = "wis") %>% ungroup()
by_week_wis_1wk <- plot_byweek_function(byweek_case, var = "wis", horizon_num = "1")
ggplotly(by_week_wis_1wk, tooltip = c("label", "labelx", "labely"))
```

### 4 Week Horizon WIS

In this figure, the dotted black line represents the average 1 week ahead error. There is often larger variation in error for the 4 week horizon compared to the 1 week horizon. 

```{r,fig.width=10, fig.height=6}
#calc 1 week error
meanwis_1wk <- byweek_case %>%
  filter(horizon == "1") %>%
  group_by(target_end_date) %>%
  summarise(mean_score = mean(mean_score, na.rm = TRUE)) %>%
  mutate(model = "`average error for 1 week horizon`",
         horizon = "4") %>%
  select(model, horizon, target_end_date, mean_score)
  

by_week_wis_4wk <- plot_byweek_function(byweek_case, var = "wis", horizon_num = "4") +
   geom_line(data = meanwis_1wk, aes(label = model, x = target_end_date, y = mean_score), alpha=.5, color = "black", linetype = 2) +
  geom_point(data = meanwis_1wk, aes(x = target_end_date, y = mean_score), alpha=.5, size = 2, color = "black") 
ggplotly(by_week_wis_4wk,tooltip = c("label", "labelx", "labely"))
```


### 1 Week Horizon 80% Coverage

We would expect a well calibrated model would have a value of 80% in this plot. 

```{r,fig.width=10, fig.height=6}
byweek_case <- by_week_function(score_case_all, var = "coverage_80")
by_week_wis_1wk <- plot_byweek_function(byweek_case, var = "coverage_80", horizon_num = "1") +
  geom_hline(yintercept = 0.8)
ggplotly(by_week_wis_1wk,tooltip = c("label", "labelx", "labely"))
```

### 4 Week Horizon 80% Coverage

We would expect a well calibrated model would have a value of 80% in this plot. There is typically larger variation in error for the 4 week horizon compared to the 1 week horizon. 

```{r,fig.width=10, fig.height=6}
by_week_wis_4wk <- plot_byweek_function(byweek_case, var = "coverage_80", horizon_num = "4") +
  geom_hline(yintercept = 0.8)

ggplotly(by_week_wis_4wk, tooltip = c("label", "labelx", "labely"))
```


## Location Specific WIS

The following figure shows the scores of models aggregated by horizon and submission week. In this figure, we only include models that have submitted forecasts for all 4 horizons and at least 50% of evaluated weeks or at least 2 weeks out of the latest 3. 
 The color scheme shows the WIS score relative to the baseline. The only locations evaluated are 50 states and a national level forecast. 

```{r fig.height=10, fig.width= 11}

plot_avg_by_loc <- function(df) {
  
  average_by_loc <- score_case_10wks %>%
  filter(horizon %in% c(1:4)) %>%
  filter(score_name == "wis") %>%
  filter(n_horizons == max(n_horizons),
         n_weeks >= max(n_weeks)*0.5 | n_weeks_3wksPrior >= 2 ) %>%
  group_by(model, location) %>%
  summarise(avg_wis = round(mean(score_value),1)) %>%
  group_by(location) %>%
  mutate(relative_wis = avg_wis / avg_wis[model == "COVIDhub-baseline"]) %>%
  ungroup() %>%
  mutate(log_relative_wis = ifelse(relative_wis == 0, 0, log2(relative_wis)),
    log_relative_wis = ifelse(log_relative_wis > 3, 3, log_relative_wis)) %>%
    filter(!is.na(relative_wis)) %>% 
  left_join(hub_locations %>% select(location = fips, abbreviation))


average_by_loc$model<- reorder(average_by_loc$model, -average_by_loc$log_relative_wis) #sort models by WIS for plot
average_by_loc$abbreviation <- reorder(average_by_loc$abbreviation, average_by_loc$avg_wis)

ggplot(average_by_loc, aes(x=model, y=abbreviation ,fill= log_relative_wis)) +
  geom_tile() +
  geom_text(aes(label=round(avg_wis)), size = 3) +
  scale_fill_gradient2(low = "steelblue", high = "red", midpoint = 0, na.value = "grey50", name = "Relative WIS", 
                       breaks = c(-2,-1,0,1,2), labels =c(0.25, 0.5, 1, 2, 4)) +
  xlab("Scored Models") + ylab("Location") +
  theme(axis.text.x = element_text(angle = 45, hjust = 1, size = 10),
      axis.title.x = element_text(size = 9),
      axis.text.y = element_text(size = 9),
      title = element_text(size = 9))
}


plot_avg_by_loc(score_case_10wks)
```


# Incident Deaths {.tabset .tabset-fade}

## Truth data and Model Submissions {.tabset .tabset-fade}

### Truth Data

This plot shows the observed number of incident deaths over the evaluation period. 
```{r, fig.width=8, fig.height=7}
truth_US_inc <- truth_dat_inc %>% filter(location == "US") 

plot_truth(truth_US_inc)
```


### Number of Locations

```{r filters for analysis inc death}
n_unique_models_inc <- length(unique(score_inc_10wks$model)) #Total models submitted during this time period

n_models_all_weeks <- score_inc_10wks %>% 
  group_by(horizon) %>%
  filter(n_weeks == max(n_weeks)) %>%
  pull(model) %>% unique() %>% length()

n_models_all_locations <- score_inc_10wks %>% 
  filter(n_locations == max(n_locations)) %>%
  pull(model) %>% unique() %>% length()

n_models_all_weeks <- score_inc_10wks %>% 
  group_by(horizon) %>%
  filter(n_horizons == max(n_horizons)) %>%
  pull(model) %>% unique() %>% length()
```

In the `r n_weeks_eval` week evaluation period, the evaluated Saturdays are `r first_eval_sat` through `r last_eval_sat`.  models submitted incident death forecasts. The number of models who submitted forecasts for incident deaths is `r n_unique_models_inc`. The number of models that submitted forecasts for all `r n_weeks_eval` was `r n_models_all_weeks`. The number of teams that submitted forecasts for all locations was `r n_models_all_locations`.


The figure below shows the number of locations that each model submitted incident death forecasts for during this evaluation period. The dates listed on the X axis are the Saturday before the first horizon. This is the Saturday associated with the target submission week. If a model is submitted on a Tuesday - Friday, the Saturday listed occurs after the submission. If the model is submitted on a Sunday or Monday, the Saturday occurs before the submission date. 


```{r,fig.width=20, fig.height=20}
for_loc_figure_inc <- score_inc_10wks %>%
  filter(score_name == "wis") %>%
  filter(horizon == "1") %>%
  group_by(model, submission_sat) %>%
  summarise(n_location = n()) %>%
  ungroup() %>%
  group_by(model, n_location) %>%
  mutate(n_weeks = n())

for_loc_figure_inc$model <- reorder(for_loc_figure_inc$model, for_loc_figure_inc$n_weeks)

plot_location(for_loc_figure_inc)
```

## LeaderBoard Table


Each week, we generate a leaderboard table to assess the interval coverage, relative weighted interval scores (WIS), and relative mean average errors (MAE) of each model.

A model is included in this table if it has  submitted forecasts for 5 or more weeks total, or if it has submitted forecasts during at least 2 out of the last 3 evaluated weeks. This inclusion criteria was applied in order to score models that submitted for a substantial amount of weeks at any point during the pandemic but may no longer be submitting, but also to evaluate new teams that have recently joined our forecasting efforts. 


In order to calculate each column in our table, different inclusion criteria were applied. 

* The first column in the table counts the total number of observations a team has submitted. The second column counts the number of columns a team has submitted over the last 10 weeks. For inclusion in these rows, a model had to have been submitted for at least 5 weeks overall, or at least 2 out of the last 3 weeks. 

* The next two columns highlight the calibration scores of models, at a 50% coverage and 95% coverage level respectively. Well calibrated models should have a 50% coverage level of 0.5 and a 95% coverage level of 0.95. The inclusion criteria for these columns is the same as for the first two columns. 

* The following columns (5 and 8) calculate the following: (5) adjusted relative WIS over the most recent `r n_weeks_eval` week period, (6) adjusted relative WIS over the historical period beginning the first week in April, (7) adjusted relative MAE over the most recent period, and (8) adjusted relative MAE over a historical period. For inclusion in the 10 week WIS and MAE calculations, a model must have target_end_dates in more than 50% of evaluated weeks in the recent evaluation period. For inclusion in the historical WIS and MAE calculations, a model must have forecasts with target_end_dates in more than 50% of evaluated weeks in the Historical evaluation period,

* All adjusted relative WIS and adjusted relative MAE calculations in this table are calculated using a pairwise approach to account variation in the difficulty of forecasting different weeks and locations. Models with an adjusted relative WIS or MAE lower than 1 are more accurate than the baseline and models with an adjusted relative WIS greater than 1 are less accurate than the baseline is predicting the number of incident cases. The code for this comparison can be found [here](https://github.com/jbracher/pairwise_comparisons). A preprint on this method for calculating the WIS can be found [here](https://arxiv.org/pdf/2005.12881.pdf). 

```{r}
#calibration table 
inc_calibration <- calib_table(score_inc_leaderboard)
```


```{r}
inc_scores <- score_inc_recent %>%
  filter(n_locations >= 25) %>%
  filter(n_weeks >= 4) %>%
  droplevels()

# bring all timezeros to Monday:
inc_scores$timezero <- inc_scores$submission_sat

# restrict to 1-4 wk ahead state-level 
scores <- inc_scores %>% filter(horizon %in% paste(1:4),  location %in% the_locations) %>%
  filter(!is.na(score_value)) %>%
  select("model", "timezero", "location", "horizon", "score_name", "score_value") %>%
  filter(score_name %in% c("abs_error", "wis")) %>%
  pivot_wider(names_from = score_name, values_from = score_value)


# the included models:
models <- unique(scores$model)


# matrices to store:
results_ratio <- results_pval <- results_pval_fcd <- matrix(ncol = length(models),
                                                            nrow = length(models),
                                                            dimnames = list(models, models))

set.seed(123) # set seed for permutation tests

for(mx in seq_along(models)){
  for(my in 1:mx){
    pwc <- pairwise_comparison(scores = scores, mx = models[mx], my = models[my],
                               permutation_test = FALSE)

    results_ratio[mx, my] <- pwc$ratio
    results_ratio[my, mx] <- 1/pwc$ratio
    ## commenting these out b/c no permutation test being run
    # results_pval[mx, my] <-
    #   results_pval[my, mx] <- pwc$pval
    # results_pval_fcd[mx, my] <-
    #   results_pval_fcd[my, mx] <- pwc$pval_fcd
  }
}

ind_baseline <- which(rownames(results_ratio) == "COVIDhub-baseline")
geom_mean_ratios <- exp(rowMeans(log(results_ratio[, -ind_baseline]), na.rm = TRUE))
ratios_baseline <- results_ratio[, "COVIDhub-baseline"]
ratios_baseline2 <- geom_mean_ratios/geom_mean_ratios["COVIDhub-baseline"]

tab <- data.frame(model = names(geom_mean_ratios),
                  geom_mean_ratios = geom_mean_ratios,
                  ratios_baseline = ratios_baseline,
                  ratios_baseline2 = ratios_baseline2)

tab <- tab[order(tab$ratios_baseline2), ]

pairwise_scores <- tab %>%
  mutate(relative_wis = round(ratios_baseline2, 2)) %>%
  select(model, relative_wis) 
```

```{r}

# matrices to store:
results_ratio <- results_pval <- results_pval_fcd <- matrix(ncol = length(models),
                                                            nrow = length(models),
                                                            dimnames = list(models, models))

set.seed(123) # set seed for permutation tests

for(mx in seq_along(models)){
  for(my in 1:mx){
    pwc <- pairabs_error_comparison(scores = scores, mx = models[mx], my = models[my],
                               permutation_test = TRUE)

    results_ratio[mx, my] <- pwc$ratio
    results_ratio[my, mx] <- 1/pwc$ratio
    results_pval[mx, my] <-
      results_pval[my, mx] <- pwc$pval
    results_pval_fcd[mx, my] <-
      results_pval_fcd[my, mx] <- pwc$pval_fcd
  }
}

ind_baseline <- which(rownames(results_ratio) == "COVIDhub-baseline")
geom_mean_ratios <- exp(rowMeans(log(results_ratio[, -ind_baseline]), na.rm = TRUE))
ratios_baseline <- results_ratio[, "COVIDhub-baseline"]
ratios_baseline2 <- geom_mean_ratios/geom_mean_ratios["COVIDhub-baseline"]

tab <- data.frame(model = names(geom_mean_ratios),
                  geom_mean_ratios = geom_mean_ratios,
                  ratios_baseline = ratios_baseline,
                  ratios_baseline2 = ratios_baseline2)

tab <- tab[order(tab$ratios_baseline2), ]


pairwise_scores_mae <- tab %>%
  mutate(relative_mae = round(ratios_baseline2, 2)) %>%
  select(model, relative_mae) 
```


```{r}
inc_scores <- score_inc_historical %>%
  filter(n_locations >= 25) %>%
  filter(n_weeks >= 4) %>%
  droplevels()

# bring all timezeros to Monday:
inc_scores$timezero <- inc_scores$submission_sat

# restrict to 1-4 wk ahead state-level 
scores <- inc_scores %>% filter(horizon %in% paste(1:4),  location %in% the_locations) %>%
  filter(!is.na(score_value)) %>%
  select("model", "timezero", "location", "horizon", "score_name", "score_value") %>%
  filter(score_name %in% c("abs_error", "wis")) %>%
  pivot_wider(names_from = score_name, values_from = score_value)


# the included models:
models <- unique(scores$model)


# matrices to store:
results_ratio <- results_pval <- results_pval_fcd <- matrix(ncol = length(models),
                                                            nrow = length(models),
                                                            dimnames = list(models, models))

set.seed(123) # set seed for permutation tests

for(mx in seq_along(models)){
  for(my in 1:mx){
    pwc <- pairwise_comparison(scores = scores, mx = models[mx], my = models[my],
                               permutation_test = FALSE)

    results_ratio[mx, my] <- pwc$ratio
    results_ratio[my, mx] <- 1/pwc$ratio
    ## commenting these out b/c no permutation test being run
    # results_pval[mx, my] <-
    #   results_pval[my, mx] <- pwc$pval
    # results_pval_fcd[mx, my] <-
    #   results_pval_fcd[my, mx] <- pwc$pval_fcd
  }
}

ind_baseline <- which(rownames(results_ratio) == "COVIDhub-baseline")
geom_mean_ratios <- exp(rowMeans(log(results_ratio[, -ind_baseline]), na.rm = TRUE))
ratios_baseline <- results_ratio[, "COVIDhub-baseline"]
ratios_baseline2 <- geom_mean_ratios/geom_mean_ratios["COVIDhub-baseline"]

tab <- data.frame(model = names(geom_mean_ratios),
                  geom_mean_ratios = geom_mean_ratios,
                  ratios_baseline = ratios_baseline,
                  ratios_baseline2 = ratios_baseline2)

tab <- tab[order(tab$ratios_baseline2), ]

historical_wis <- tab %>%
  mutate(relative_wis_historical = round(ratios_baseline2, 2)) %>%
  select(model, relative_wis_historical) 
```

```{r}
# matrices to store:
results_ratio <- results_pval <- results_pval_fcd <- matrix(ncol = length(models),
                                                            nrow = length(models),
                                                            dimnames = list(models, models))

set.seed(123) # set seed for permutation tests

for(mx in seq_along(models)){
  for(my in 1:mx){
    pwc <- pairabs_error_comparison(scores = scores, mx = models[mx], my = models[my],
                               permutation_test = FALSE)

    results_ratio[mx, my] <- pwc$ratio
    results_ratio[my, mx] <- 1/pwc$ratio
    ## commenting these out b/c no permutation test being run
    # results_pval[mx, my] <-
    #       results_pval[my, mx] <- pwc$pval
    #     results_pval_fcd[mx, my] <-
    #       results_pval_fcd[my, mx] <- pwc$pval_fcd
  }
}

ind_baseline <- which(rownames(results_ratio) == "COVIDhub-baseline")
geom_mean_ratios <- exp(rowMeans(log(results_ratio[, -ind_baseline]), na.rm = TRUE))
ratios_baseline <- results_ratio[, "COVIDhub-baseline"]
ratios_baseline2 <- geom_mean_ratios/geom_mean_ratios["COVIDhub-baseline"]

tab <- data.frame(model = names(geom_mean_ratios),
                  geom_mean_ratios = geom_mean_ratios,
                  ratios_baseline = ratios_baseline,
                  ratios_baseline2 = ratios_baseline2)

tab <- tab[order(tab$ratios_baseline2), ]


historical_mae <- tab %>%
  mutate(historical_relative_mae = round(ratios_baseline2, 2)) %>%
  select(model, historical_relative_mae) 
```



```{r}
leaderboard_table <- inc_calibration %>%
  left_join(pairwise_scores) %>%
  left_join(historical_wis) %>% 
  left_join(pairwise_scores_mae) %>%
  left_join(historical_mae) %>%
  arrange(relative_wis)

DT::datatable(leaderboard_table, colnames = c("", "Model", "n historical forecasts", "n forecasts in the last 10 wks", "50% Coverage", "95% Coverage", "Relative WIS", "Historical Relative WIS", "Relative MAE", "Historical Relative MAE"), options = list(pageLength = 10, na.last = TRUE), filter = c("top"))
```



## Evaluation by Week  {.tabset .tabset-fade}

In the following figures, we have evaluated models across multiple forecasting weeks. The models included in this comparison must have submitted forecasts for all 50 states and at a national level for each timepoint. 

For the first 2 figures, WIS is used as a metric. The first figure shows the mean WIS across all locations for each submission week at a 1 week horizon. The second figure shows the mean WIS aggregated across locations, however it is for a 4 week horizon.

To view specific teams, double click on the team names in the legend. To view a value on the plot, click on the point in the forecast of interest.



### 1 Week Horizon
```{r,fig.width=10, fig.height=6}
byweek_inc <- by_week_function(score_inc_all, var = "wis")
by_week_wis_1wk <- plot_byweek_function(byweek_inc, var = "wis", horizon_num = "1") +
  geom_hline(yintercept = 0.8)
ggplotly(by_week_wis_1wk, tooltip = c("label", "labelx", "labely"))
```


### 4 Week Horizon WIS

In this figure, the dotted black line represents the average 1 week ahead error. There is larger variation in error for the 4 week horizon compared to the 1 week horizon. 

```{r,fig.width=10, fig.height=6}
#calc 1 week error
meanwis_1wk <- byweek_inc %>%
  filter(horizon == "1") %>%
  group_by(target_end_date) %>%
  summarise(mean_score = mean(mean_score, na.rm = TRUE)) %>%
  mutate(model = "`average wis or 1 week horizon`",
         horizon = "4") %>%
  select(model, horizon, target_end_date, mean_score)
  
by_week_wis_4wk <- plot_byweek_function(byweek_inc, var = "wis", horizon_num = "4") +
   geom_line(data = meanwis_1wk, aes(x = target_end_date, y = mean_score), alpha=.5, color = "black", linetype = 2) +
  geom_point(data = meanwis_1wk, aes(x = target_end_date, y = mean_score), alpha=.5, size = 2, color = "black") 
ggplotly(by_week_wis_4wk,tooltip = c("label", "labelx", "labely"))
```


### 1 Week Horizon 80% Coverage

The black line represents 80% 
```{r,fig.width=10, fig.height=6}
byweek_inc <- by_week_function(score_inc_all, var = "coverage_80")
by_week_wis_1wk <- plot_byweek_function(byweek_inc, var = "coverage_80", horizon_num = "1") +
  geom_hline(yintercept = 0.8)
ggplotly(by_week_wis_1wk, tooltip = c("label", "labelx", "labely"))
```

### 4 Week Horizon 80% Coverage

The black line represents 80% 
```{r,fig.width=10, fig.height=6}
by_week_wis_4wk <- plot_byweek_function(byweek_inc, var = "coverage_80", horizon_num = "4") +
  geom_hline(yintercept = 0.8)

ggplotly(by_week_wis_4wk, tooltip = c("label", "labelx", "labely"))
```


## Location Specific WIS
Finally, we have evaluated which locations teams had the lowest WIS scores for. In this figure, models were included if they submitted forecasts for all submission weeks and all horizons. The WIS scores stratified by location are included in each box. The color scheme shows the WIS score relative to the baseline. 
```{r fig.height=10, fig.width= 11}
plot_avg_by_loc(score_inc_10wks)
```


